#!/bin/python3
import sys
import binascii

if len(sys.argv) != 2:
    print("Usage:",sys.argv[0],"input")
    sys.exit(0)

print("Reading:", sys.argv[1])
with open(sys.argv[1], "rb") as f:
    data = f.read()

print("Bytes read:", len(data))

# determine address width
awidth = -1
l = len(data)
while(l):
    awidth += 1
    l >>= 1

print("Addr width:", awidth)

# determine data width
pattern = 0
for c in data: pattern |= c

dwidth = 8
while not pattern & (1<<(dwidth-1)):
    dwidth -= 1

print("Data width:", dwidth)

# determine data bus width bits
dwbits = -1
l = dwidth
while(l):
    dwbits += 1
    l >>= 1
    
if False:
    # create mi file    
    outname = sys.argv[1].replace(".","_") + ".mi"
    print("Writing:", outname)

    with open(outname, "w") as f:
        print("#File_format=Bin", file=f)
        print("#Address_depth={}".format(len(data)), file=f)
        print("#Data_width={}".format(dwidth), file=f)

        for byte in data:
            print(("{:0"+str(dwidth)+"b}").format(byte), file=f)
    
else:
    # create verilog file
    outname = sys.argv[1].replace(".","_")
    print("Writing:", outname+".v")

    with open(outname + ".v", "w") as f:        
        print("// "+outname+".v"" generated by bin2v.py", file=f)

        # prepend "prom_" to module name if it begins with a digit    
        if outname[0].isdigit():
            outname = "prom_" + outname
        
        print("", file=f)
        
        print("module "+outname+" (dout, clk, oce, ce, reset, ad);", file=f)
        print("", file=f)
        
        print("output ["+str(dwidth-1)+":0] dout;", file=f)
        print("input clk;", file=f)
        print("input oce;", file=f)
        print("input ce;", file=f)
        print("input reset;", file=f)
        print("input ["+str(awidth-1)+":0] ad;", file=f)
        print("", file=f)

        # max 2kbytes per instance
        instances = (len(data)+2047)//2048        
        instance_bits = dwidth//instances
        dwbits -= (instances-1)   
        if instances > 2: raise ValueError("Max 2 iinstances supported")
        
        # internal prom output is 32 bits
        for i in range(instances):
            print("wire ["+str(32-instance_bits-1)+":0] prom_inst_"+str(i)+"_dout_w;", file=f) 

        print("wire gw_gnd;", file=f) 
        print("", file=f)

        print("assign gw_gnd = 1'b0;", file=f)
        print("", file=f)

        for inst in range(instances):
            print("pROM prom_inst_"+str(inst)+" (", file=f)
            print("    .DO({prom_inst_"+str(inst)+"_dout_w["+str(32-instance_bits-1)+":0],dout["+str((inst+1)*instance_bits-1)+":"+str(inst*instance_bits)+"]}),", file=f)
            print("    .CLK(clk),", file=f)
            print("    .OCE(oce),", file=f)
            print("    .CE(ce),", file=f)
            print("    .RESET(reset),", file=f)
            
            # rom is 14 bits wide
            abit_strs = []
            # determine dbus with
            for i in range(14-awidth-dwbits): abit_strs.append("gw_gnd")
            abit_strs.append("ad["+str(awidth-1)+":0]")
            for i in range(dwbits): abit_strs.append("gw_gnd")
            
            print("    .AD({"+",".join(abit_strs)+"})", file=f)
            print(");", file=f)
            print("", file=f)

            defparam_str = "defparam prom_inst_"+str(inst)+"."
            
            print(defparam_str+"READ_MODE = 1'b0;", file=f)
            print(defparam_str+"BIT_WIDTH = "+str(instance_bits)+";", file=f)
            print(defparam_str+"RESET_MODE = \"SYNC\";", file=f)

            # output data in sequences of 256 bits
            for sidx in range((len(data)*dwidth)//(instances*256)):
#                print("seq idx", sidx)

                if instance_bits == 8:
                    seq = bytearray(data[32*sidx:32*(sidx+1)])
                elif instance_bits == 4:
                    # convert array of 4 bit values into byte sequence
                    seq = []
                    for b in range(32):
                        b0 = data[64*sidx+2*b]
                        b1 = data[64*sidx+2*b+1]

                        if inst == 0:
                            b0 &= 0x0f
                            b1 &= 0x0f
                        else:
                            b0 >>= 4
                            b1 >>= 4
                        
                        seq.append((b1<<4) + b0)
                    seq = bytearray(seq)
                else:
                    raise ValueError("Only 4 or 8 bits per instance supported!")
                    
                seq.reverse()
                print(defparam_str+"INIT_RAM_{:02X} = 256'h".format(sidx)+binascii.hexlify(seq).decode().upper()+";", file=f)
            print("", file=f)
            
        print("endmodule //"+outname, file=f)



